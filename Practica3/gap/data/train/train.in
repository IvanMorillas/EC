#############################################################################
##
#A  combinat.tst                GAP tests                    Martin Schoenert
##
#A  @(#)$Id: combinat.tst,v 3.2 1992/11/25 14:49:10 martin Exp $
##
#Y  Copyright 1990-1992,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
##  This  file  tests  the functions that  mainly  deal  with  combinatorics.
##
#H  $Log: combinat.tst,v $
#H  Revision 3.2  1992/11/25  14:49:10  martin
#H  changed the format of the message
#H
#H  Revision 3.1  1992/04/29  08:53:40  martin
#H  changed the output (because of the new printer)
#H
#H  Revision 3.0  1991/07/22  18:13:03  martin
#H  initial revision under RCS
#H
##

#F  Factorial( <n> )  . . . . . . . . . . . . . . . . factorial of an integer
List( [0..10], Factorial );
#>[ 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 ]
Factorial( 50 );
#>30414093201713378043612608166064768844377641568960512000000000000

#F  Binomial( <n>, <k> )  . . . . . . . . .  binomial coefficient of integers
List( [-8..8], k -> Binomial( 0, k ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
List( [-8..8], n -> Binomial( n, 0 ) );
#>[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
##NEW
#ForAll( [-50..50], n -> ForAll( [-20..50], k ->
#    Binomial(n,k) = Binomial(n-1,k) + Binomial(n-1,k-1) ) );
#>true
Binomial( 400, 50 );
#>17035900270730601418919867558071677342938596450600561760371485120

#F  Bell( <n> ) . . . . . . . . . . . . . . . . .  value of the Bell sequence
List( [0..10], n -> Bell(n) );
#>[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ]
List( [0..10], n -> Sum( [0..n], k -> Stirling2( n, k ) ) );
#>[ 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ]
Bell( 60 );
#>976939307467007552986994066961675455550246347757474482558637

#F  Stirling1( <n>, <k> ) . . . . . . . . . Stirling number of the first kind
List( [-8..8], k -> Stirling1( 0, k ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
List( [-8..8], n -> Stirling1( n, 0 ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
##NEW
ForAll( [-40..40], n -> ForAll( [-40..40], k ->
    Stirling1(n,k) = (n-1) * Stirling1(n-1,k) + Stirling1(n-1,k-1) ) );
#>true
Stirling1( 60, 20 );
#>568611292461582075463109862277030309493811818619783570055397018154658816

#F  Stirling2( <n>, <k> ) . . . . . . . .  Stirling number of the second kind
List( [-8..8], k -> Stirling2( 0, k ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
List( [-8..8], n -> Stirling2( n, 0 ) );
#>[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]
##NEW
ForAll( [-40..40], n -> ForAll( [-40..40], k ->
    Stirling2(n,k) = k * Stirling2(n-1,k) + Stirling2(n-1,k-1) ) );
#>true
Stirling2( 60, 20 );
#>170886257768137628374668205554120607567311094075812403938286

#F  Combinations( <mset>, <k> ) . . . .  set of sorted sublists of a multiset
Combinations( [] );
#>[ [  ] ]
List( [0..1], k -> Combinations( [], k ) );
#>[ [ [  ] ], [  ] ]
Combinations( [1..4] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 3 ], [ 1, 2, 3, 4 ], [ 1, 2, 4 ], [ 1, 3 ], 
#>  [ 1, 3, 4 ], [ 1, 4 ], [ 2 ], [ 2, 3 ], [ 2, 3, 4 ], [ 2, 4 ], [ 3 ], 
#>  [ 3, 4 ], [ 4 ] ]
List( [0..5], k -> Combinations( [1..4], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ], 
#>  [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ], [ [ 1, 2, 3, 4 ] ], 
#>  [  ] ]
Combinations( [1,2,2,3] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 2 ], [ 1, 2, 2, 3 ], [ 1, 2, 3 ], [ 1, 3 ], 
#>  [ 2 ], [ 2, 2 ], [ 2, 2, 3 ], [ 2, 3 ], [ 3 ] ]
List( [0..5], k -> Combinations( [1,2,2,3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ] ], 
#>  [ [ 1, 2, 2 ], [ 1, 2, 3 ], [ 2, 2, 3 ] ], [ [ 1, 2, 2, 3 ] ], [  ] ]
Combinations( [1..12] )[4039];
#>[ 7, 8, 9, 10, 11, 12 ]
Combinations( [1..16], 4 )[266];
#>[ 1, 5, 9, 13 ]
Combinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7] )[378];
#>[ 1, 2, 3, 4, 5, 6, 7 ]
Combinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,8], 8 )[97];
#>[ 1, 2, 3, 4, 5, 6, 7, 8 ]
##NEW
Combinations( [1..17] )[2^17];
#>[ 17 ]

#F  NrCombinations( <mset>, <k> ) . . number of sorted sublists of a multiset
NrCombinations( [] );
#>1
List( [0..1], k -> NrCombinations( [], k ) );
#>[ 1, 0 ]
NrCombinations( [1..4] );
#>16
List( [0..5], k -> NrCombinations( [1..4], k ) );
#>[ 1, 4, 6, 4, 1, 0 ]
NrCombinations( [1,2,2,3] );
#>12
List( [0..5], k -> NrCombinations( [1,2,2,3], k ) );
#>[ 1, 3, 4, 3, 1, 0 ]
NrCombinations( [1..12] );
#>4096
NrCombinations( [1..16], 4 );
#>1820
NrCombinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7] );
#>2880
NrCombinations( [1,2,3,3,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,8], 8 );
#>1558

#F  Arrangements( <mset> )  . . . . set of ordered combinations of a multiset
Arrangements( [] );
#>[ [  ] ]
List( [0..1], k -> Arrangements( [], k ) );
#>[ [ [  ] ], [  ] ]
Arrangements( [1..3] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 3 ], [ 1, 3 ], [ 1, 3, 2 ], [ 2 ], [ 2, 1 ], 
#>  [ 2, 1, 3 ], [ 2, 3 ], [ 2, 3, 1 ], [ 3 ], [ 3, 1 ], [ 3, 1, 2 ], [ 3, 2 ], 
#>  [ 3, 2, 1 ] ]
List( [0..4], k -> Arrangements( [1..3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ] ], 
#>  [ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 3 ], [ 2, 3, 1 ], [ 3, 1, 2 ], 
#>      [ 3, 2, 1 ] ], [  ] ]
Arrangements( [1,2,2,3] );
#>[ [  ], [ 1 ], [ 1, 2 ], [ 1, 2, 2 ], [ 1, 2, 2, 3 ], [ 1, 2, 3 ], 
#>  [ 1, 2, 3, 2 ], [ 1, 3 ], [ 1, 3, 2 ], [ 1, 3, 2, 2 ], [ 2 ], [ 2, 1 ], 
#>  [ 2, 1, 2 ], [ 2, 1, 2, 3 ], [ 2, 1, 3 ], [ 2, 1, 3, 2 ], [ 2, 2 ], 
#>  [ 2, 2, 1 ], [ 2, 2, 1, 3 ], [ 2, 2, 3 ], [ 2, 2, 3, 1 ], [ 2, 3 ], 
#>  [ 2, 3, 1 ], [ 2, 3, 1, 2 ], [ 2, 3, 2 ], [ 2, 3, 2, 1 ], [ 3 ], [ 3, 1 ], 
#>  [ 3, 1, 2 ], [ 3, 1, 2, 2 ], [ 3, 2 ], [ 3, 2, 1 ], [ 3, 2, 1, 2 ], 
#>  [ 3, 2, 2 ], [ 3, 2, 2, 1 ] ]
List( [0..5], k -> Arrangements( [1,2,2,3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], [ 3, 2 ] ], 
#>  [ [ 1, 2, 2 ], [ 1, 2, 3 ], [ 1, 3, 2 ], [ 2, 1, 2 ], [ 2, 1, 3 ], 
#>      [ 2, 2, 1 ], [ 2, 2, 3 ], [ 2, 3, 1 ], [ 2, 3, 2 ], [ 3, 1, 2 ], 
#>      [ 3, 2, 1 ], [ 3, 2, 2 ] ], 
#>  [ [ 1, 2, 2, 3 ], [ 1, 2, 3, 2 ], [ 1, 3, 2, 2 ], [ 2, 1, 2, 3 ], 
#>      [ 2, 1, 3, 2 ], [ 2, 2, 1, 3 ], [ 2, 2, 3, 1 ], [ 2, 3, 1, 2 ], 
#>      [ 2, 3, 2, 1 ], [ 3, 1, 2, 2 ], [ 3, 2, 1, 2 ], [ 3, 2, 2, 1 ] ], [  ] ]
Arrangements( [1..6] )[736];
#>[ 3, 2, 1, 6, 5, 4 ]
Arrangements( [1..8], 4 )[443];
#>[ 3, 1, 7, 5 ]
Arrangements( [1,2,3,3,4,4,5] )[3511];
#>[ 5, 4, 3, 2, 1 ]
Arrangements( [1,2,3,4,4,5,5,6,6], 5 )[424];
#>[ 2, 3, 4, 5, 6 ]

#F  NrArrangements( <mset>, <k> ) . . number of sorted sublists of a multiset
NrArrangements( [] );
#>1
List( [0..1], k -> NrArrangements( [], k ) );
#>[ 1, 0 ]
NrArrangements( [1..3] );
#>16
List( [0..4], k -> NrArrangements( [1..3], k ) );
#>[ 1, 3, 6, 6, 0 ]
NrArrangements( [1,2,2,3] );
#>35
List( [0..5], k -> NrArrangements( [1,2,2,3], k ) );
#>[ 1, 3, 7, 12, 12, 0 ]
NrArrangements( [1..6] );
#>1957
NrArrangements( [1..8], 4 );
#>1680
NrArrangements( [1,2,3,3,4,4,5] );
#>3592
NrArrangements( [1,2,3,4,4,5,5,6,6], 5 );
#>2880

#F  UnorderedTuples( <set>, <k> ) . . . .  set of unordered tuples from a set
List( [0..1], k -> UnorderedTuples( [], k ) );
#>[ [ [  ] ], [  ] ]
List( [0..4], k -> UnorderedTuples( [1..3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 2 ], [ 2, 3 ], [ 3, 3 ] ], 
#>  [ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 2 ], [ 1, 2, 3 ], 
#>      [ 1, 3, 3 ], [ 2, 2, 2 ], [ 2, 2, 3 ], [ 2, 3, 3 ], [ 3, 3, 3 ] ], 
#>  [ [ 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 1, 3 ], [ 1, 1, 2, 2 ], 
#>      [ 1, 1, 2, 3 ], [ 1, 1, 3, 3 ], [ 1, 2, 2, 2 ], [ 1, 2, 2, 3 ], 
#>      [ 1, 2, 3, 3 ], [ 1, 3, 3, 3 ], [ 2, 2, 2, 2 ], [ 2, 2, 2, 3 ], 
#>      [ 2, 2, 3, 3 ], [ 2, 3, 3, 3 ], [ 3, 3, 3, 3 ] ] ]
UnorderedTuples( [1..10], 6 )[1459];
#>[ 1, 3, 5, 7, 9, 10 ]
##NEW
UnorderedTuples( [1..18], 6 )[ NrUnorderedTuples( [1..18], 6 ) ];
#>[ 18, 18, 18, 18, 18, 18 ]

#F  NrUnorderedTuples( <set>, <k> ) . . number unordered of tuples from a set
List( [0..1], k -> NrUnorderedTuples( [], k ) );
#>[ 1, 0 ]
List( [0..4], k -> NrUnorderedTuples( [1..3], k ) );
#>[ 1, 3, 6, 10, 15 ]
NrUnorderedTuples( [1..10], 6 );
#>5005

#F  Tuples( <set>, <k> )  . . . . . . . . .  set of ordered tuples from a set
List( [0..1], k -> Tuples( [], k ) );
#>[ [ [  ] ], [  ] ]
List( [0..3], k -> Tuples( [1..3], k ) );
#>[ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], 
#>  [ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 1 ], 
#>      [ 3, 2 ], [ 3, 3 ] ], 
#>  [ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 1 ], [ 1, 2, 2 ], 
#>      [ 1, 2, 3 ], [ 1, 3, 1 ], [ 1, 3, 2 ], [ 1, 3, 3 ], [ 2, 1, 1 ], 
#>      [ 2, 1, 2 ], [ 2, 1, 3 ], [ 2, 2, 1 ], [ 2, 2, 2 ], [ 2, 2, 3 ], 
#>      [ 2, 3, 1 ], [ 2, 3, 2 ], [ 2, 3, 3 ], [ 3, 1, 1 ], [ 3, 1, 2 ], 
#>      [ 3, 1, 3 ], [ 3, 2, 1 ], [ 3, 2, 2 ], [ 3, 2, 3 ], [ 3, 3, 1 ], 
#>      [ 3, 3, 2 ], [ 3, 3, 3 ] ] ]
Tuples( [1..8], 4 )[167];
#>[ 1, 3, 5, 7 ]

#F  NrTuples( <set>, <k> )  . . . . . . . number of ordered tuples from a set
List( [0..1], k -> NrTuples( [], k ) );
#>[ 1, 0 ]
List( [0..3], k -> NrTuples( [1..3], k ) );
#>[ 1, 3, 9, 27 ]
NrTuples( [1..8], 4 );
#>4096

#F  PermutationsList( <mset> )  . . . . . . set of permutations of a multiset
PermutationsList( [] );
#>[ [  ] ]
PermutationsList( [1..4] );
#>[ [ 1, 2, 3, 4 ], [ 1, 2, 4, 3 ], [ 1, 3, 2, 4 ], [ 1, 3, 4, 2 ], 
#>  [ 1, 4, 2, 3 ], [ 1, 4, 3, 2 ], [ 2, 1, 3, 4 ], [ 2, 1, 4, 3 ], 
#>  [ 2, 3, 1, 4 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 2, 4, 3, 1 ], 
#>  [ 3, 1, 2, 4 ], [ 3, 1, 4, 2 ], [ 3, 2, 1, 4 ], [ 3, 2, 4, 1 ], 
#>  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 1, 3, 2 ], 
#>  [ 4, 2, 1, 3 ], [ 4, 2, 3, 1 ], [ 4, 3, 1, 2 ], [ 4, 3, 2, 1 ] ]
PermutationsList( [1,2,2,3,] );
#>[ [ 1, 2, 2, 3 ], [ 1, 2, 3, 2 ], [ 1, 3, 2, 2 ], [ 2, 1, 2, 3 ], 
#>  [ 2, 1, 3, 2 ], [ 2, 2, 1, 3 ], [ 2, 2, 3, 1 ], [ 2, 3, 1, 2 ], 
#>  [ 2, 3, 2, 1 ], [ 3, 1, 2, 2 ], [ 3, 2, 1, 2 ], [ 3, 2, 2, 1 ] ]
PermutationsList( [1..6] )[ 128 ];
#>[ 2, 1, 4, 3, 6, 5 ]
PermutationsList( [1,2,2,3,3,4,4,4] )[1359];
#>[ 4, 3, 2, 1, 4, 3, 2, 4 ]

#F  NrPermutationsList( <mset> )  . . .  number of permutations of a multiset
NrPermutationsList( [] );
#>1
NrPermutationsList( [1..4] );
#>24
NrPermutationsList( [1,2,2,3] );
#>12
NrPermutationsList( [1..6] );
#>720
NrPermutationsList( [1,2,2,3,3,4,4,4] );
#>1680

#F  Derangements( <list> ) . . . . set of fixpointfree permutations of a list
Derangements( [] );
#>[ [  ] ]
Derangements( [1..4] );
#>[ [ 2, 1, 4, 3 ], [ 2, 3, 4, 1 ], [ 2, 4, 1, 3 ], [ 3, 1, 4, 2 ], 
#>  [ 3, 4, 1, 2 ], [ 3, 4, 2, 1 ], [ 4, 1, 2, 3 ], [ 4, 3, 1, 2 ], 
#>  [ 4, 3, 2, 1 ] ]
Derangements( [1..6] )[ 128 ];
#>[ 4, 3, 6, 1, 2, 5 ]
Derangements( [1,2,2,3,3,4,4,4] )[64];
#>[ 4, 1, 4, 2, 4, 2, 3, 3 ]

#F  NrDerangements( <list> ) .  number of fixpointfree permutations of a list
NrDerangements( [] );
#>1
NrDerangements( [1..4] );
#>9
NrDerangements( [1..6] );
#>265
NrDerangements( [1,2,2,3,3,4,4,4] );
#>126

#F  Permanent( <mat> )  . . . . . . . . . . . . . . . . permanent of a matrix
Permanent( [[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]] );
#>9
Permanent( [[1,1,0,1,0,0,0],[0,1,1,0,1,0,0],[0,0,1,1,0,1,0],[0,0,0,1,1,0,1],
            [1,0,0,0,1,1,0],[0,1,0,0,0,1,1],[1,0,1,0,0,0,1]] );
#>24

#F  PartitionsSet( <set> )  . . . . . . . . . . .  set of partitions of a set
PartitionsSet( [] );
#>[ [  ] ]
List( [0..1], k -> PartitionsSet( [], k ) );
#>[ [ [  ] ], [  ] ]
PartitionsSet( [1..4] );
#>[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ] ], [ [ 1 ], [ 2 ], [ 3, 4 ] ], 
#>  [ [ 1 ], [ 2, 3 ], [ 4 ] ], [ [ 1 ], [ 2, 3, 4 ] ], 
#>  [ [ 1 ], [ 2, 4 ], [ 3 ] ], [ [ 1, 2 ], [ 3 ], [ 4 ] ], 
#>  [ [ 1, 2 ], [ 3, 4 ] ], [ [ 1, 2, 3 ], [ 4 ] ], [ [ 1, 2, 3, 4 ] ], 
#>  [ [ 1, 2, 4 ], [ 3 ] ], [ [ 1, 3 ], [ 2 ], [ 4 ] ], [ [ 1, 3 ], [ 2, 4 ] ], 
#>  [ [ 1, 3, 4 ], [ 2 ] ], [ [ 1, 4 ], [ 2 ], [ 3 ] ], [ [ 1, 4 ], [ 2, 3 ] ] ]
List( [0..4], k -> PartitionsSet( [1..3], k ) );
#>[ [  ], [ [ [ 1, 2, 3 ] ] ], 
#>  [ [ [ 1 ], [ 2, 3 ] ], [ [ 1, 2 ], [ 3 ] ], [ [ 1, 3 ], [ 2 ] ] ], 
#>  [ [ [ 1 ], [ 2 ], [ 3 ] ] ], [  ] ]
PartitionsSet( [1..7] )[521];
#>[ [ 1, 3, 5, 7 ], [ 2, 4, 6 ] ]
PartitionsSet( [1..8], 3 )[96];
#>[ [ 1, 2, 3 ], [ 4, 5 ], [ 6, 7, 8 ] ]

#F  NrPartitionsSet( <set> )  . . . . . . . . . number of partitions of a set
NrPartitionsSet( [] );
#>1
List( [0..1], k -> NrPartitionsSet( [], k ) );
#>[ 1, 0 ]
NrPartitionsSet( [1..4] );
#>15
List( [0..4], k -> NrPartitionsSet( [1,2,3], k ) );
#>[ 0, 1, 3, 1, 0 ]
NrPartitionsSet( [1..8] );
#>4140
NrPartitionsSet( [1..9], 3 );
#>3025

#F  Partitions( <n> ) . . . . . . . . . . . . set of partitions of an integer
Partitions( 0 );
#>[ [  ] ]
List( [0..1], k -> Partitions( 0, k ) );
#>[ [ [  ] ], [  ] ]
Partitions( 6 );
#>[ [ 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 2, 2 ], 
#>  [ 3, 1, 1, 1 ], [ 3, 2, 1 ], [ 3, 3 ], [ 4, 1, 1 ], [ 4, 2 ], [ 5, 1 ], 
#>  [ 6 ] ]
List( [0..7], k -> Partitions( 6, k ) );
#>[ [  ], [ [ 6 ] ], [ [ 3, 3 ], [ 4, 2 ], [ 5, 1 ] ], 
#>  [ [ 2, 2, 2 ], [ 3, 2, 1 ], [ 4, 1, 1 ] ], 
#>  [ [ 2, 2, 1, 1 ], [ 3, 1, 1, 1 ] ], [ [ 2, 1, 1, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 1, 1, 1 ] ], [  ] ]
Partitions( 20 )[314];
#>[ 7, 4, 3, 3, 2, 1 ]
Partitions( 20, 10 )[17];
#>[ 5, 3, 3, 2, 2, 1, 1, 1, 1, 1 ]

#F  NrPartitions( <n> ) . . . . . . . . .  number of partitions of an integer
NrPartitions( 0 );
#>1
List( [0..1], k -> NrPartitions( 0, k ) );
#>[ 1, 0 ]
NrPartitions( 6 );
#>11
List( [0..7], k -> NrPartitions( 6, k ) );
#>[ 0, 1, 3, 3, 2, 1, 1, 0 ]
NrPartitions( 100 );
#>190569292
NrPartitions( 100, 10 );
#>2977866

#F  OrderedPartitions( <n> ) . . . .  set of ordered partitions of an integer
OrderedPartitions( 0 );
#>[ [  ] ]
List( [0..1], k -> OrderedPartitions( 0, k ) );
#>[ [ [  ] ], [  ] ]
OrderedPartitions( 5 );
#>[ [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 1, 3 ], 
#>  [ 1, 2, 1, 1 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 1, 4 ], [ 2, 1, 1, 1 ], 
#>  [ 2, 1, 2 ], [ 2, 2, 1 ], [ 2, 3 ], [ 3, 1, 1 ], [ 3, 2 ], [ 4, 1 ], [ 5 ] ]
List( [0..6], k -> OrderedPartitions( 5, k ) );
#>[ [  ], [ [ 5 ] ], [ [ 1, 4 ], [ 2, 3 ], [ 3, 2 ], [ 4, 1 ] ], 
#>  [ [ 1, 1, 3 ], [ 1, 2, 2 ], [ 1, 3, 1 ], [ 2, 1, 2 ], [ 2, 2, 1 ], 
#>      [ 3, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 2 ], [ 1, 1, 2, 1 ], [ 1, 2, 1, 1 ], [ 2, 1, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 1, 1 ] ], [  ] ]
OrderedPartitions( 13 )[2048];
#>[ 1, 12 ]
OrderedPartitions( 16, 6 )[1001];
#>[ 1, 11, 1, 1, 1, 1 ]

#F  NrOrderedPartitions( <n> ) . . number of ordered partitions of an integer
NrOrderedPartitions( 0 );
#>1
List( [0..1], k -> NrOrderedPartitions( 0, k ) );
#>[ 1, 0 ]
NrOrderedPartitions( 5 );
#>16
List( [0..6], k -> NrOrderedPartitions( 5, k ) );
#>[ 0, 1, 4, 6, 4, 1, 0 ]
NrOrderedPartitions( 13 );
#>4096
NrOrderedPartitions( 16, 6 );
#>3003

#F  RestrictedPartitions( <n>, <set> )  . restricted partitions of an integer
RestrictedPartitions( 0, [1..10] );
#>[ [  ] ]
List( [0..1], k -> RestrictedPartitions( 0, [1..10], k ) );
#>[ [ [  ] ], [  ] ]
RestrictedPartitions( 10, [1,2,5,10] );
#>[ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ], 
#>  [ 2, 2, 1, 1, 1, 1, 1, 1 ], [ 2, 2, 2, 1, 1, 1, 1 ], [ 2, 2, 2, 2, 1, 1 ], 
#>  [ 2, 2, 2, 2, 2 ], [ 5, 1, 1, 1, 1, 1 ], [ 5, 2, 1, 1, 1 ], [ 5, 2, 2, 1 ], 
#>  [ 5, 5 ], [ 10 ] ]
List( [1..10], k -> RestrictedPartitions( 10, [1,2,5,10], k ) );
#>[ [ [ 10 ] ], [ [ 5, 5 ] ], [  ], [ [ 5, 2, 2, 1 ] ], 
#>  [ [ 2, 2, 2, 2, 2 ], [ 5, 2, 1, 1, 1 ] ], 
#>  [ [ 2, 2, 2, 2, 1, 1 ], [ 5, 1, 1, 1, 1, 1 ] ], [ [ 2, 2, 2, 1, 1, 1, 1 ] ],
#>  [ [ 2, 2, 1, 1, 1, 1, 1, 1 ] ], [ [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ] ], 
#>  [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ] ]
RestrictedPartitions( 20, [2,5,10] );
#>[ [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ], [ 5, 5, 2, 2, 2, 2, 2 ], [ 5, 5, 5, 5 ], 
#>  [ 10, 2, 2, 2, 2, 2 ], [ 10, 5, 5 ], [ 10, 10 ] ]
List( [1..20], k -> RestrictedPartitions( 20, [2,5,10], k ) );
#>[ [  ], [ [ 10, 10 ] ], [ [ 10, 5, 5 ] ], [ [ 5, 5, 5, 5 ] ], [  ], 
#>  [ [ 10, 2, 2, 2, 2, 2 ] ], [ [ 5, 5, 2, 2, 2, 2, 2 ] ], [  ], [  ], 
#>  [ [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ] ], [  ], [  ], [  ], [  ], [  ], [  ], 
#>  [  ], [  ], [  ], [  ] ]
RestrictedPartitions( 60, [2,3,5,7,11,13,17] )[600];
#>[ 13, 7, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ]
RestrictedPartitions( 100, [2,3,5,7,11,13,17], 10 )[75];
#>[ 17, 17, 13, 13, 13, 7, 5, 5, 5, 5 ]

#F  NrRestrictedPartitions(<n>,<set>) . . . . number of restricted partitions
NrRestrictedPartitions( 0, [1..10] );
#>1
List( [0..1], k -> NrRestrictedPartitions( 0, [1..10], k ) );
#>[ 1, 0 ]
NrRestrictedPartitions( 50, [1,2,5,10] );
#>341
List( [1..50], k -> NrRestrictedPartitions( 50, [1,2,5,10], k ) );
#>[ 0, 0, 0, 0, 1, 1, 1, 2, 4, 6, 6, 8, 10, 11, 11, 12, 13, 14, 14, 14, 15, 15, 
#>  14, 14, 14, 13, 12, 12, 11, 10, 9, 9, 8, 7, 6, 6, 6, 5, 4, 4, 4, 3, 2, 2, 
#>  2, 2, 1, 1, 1, 1 ]
NrRestrictedPartitions( 50, [2,5,10] );
#>21
List( [1..50], k -> NrRestrictedPartitions( 50, [2,5,10], k ) );
#>[ 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 
#>  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
NrRestrictedPartitions( 60, [2,3,5,7,11,13,17] );
#>1213
NrRestrictedPartitions( 100, [2,3,5,7,11,13,17], 10 );
#>125

#F  Lucas(<P>,<Q>,<k>)  . . . . . . . . . . . . . . value of a lucas sequence
List( [0..10], i->Lucas(1,-2,i)[1] );
#>[ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341 ]
List( [0..10], i->Lucas(1,-2,i)[2] );
#>[ 2, 1, 5, 7, 17, 31, 65, 127, 257, 511, 1025 ]
List( [0..10], i->Lucas(1,-1,i)[1] );
#>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
List( [0..10], i->Lucas(2,1,i)[1] );
#>[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
Lucas( 0, -4, 100 ) = [ 0, 2^101, 4^100 ];
#>true

#F  Fibonacci( <n> )  . . . . . . . . . . . . value of the Fibonacci sequence
List( [0..17], Fibonacci );
#>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597 ]
Fibonacci( 333 );
#>1751455877444438095408940282208383549115781784912085789506677971125378

#F  Bernoulli( <n> )  . . . . . . . . . . . . value of the Bernoulli sequence
List( [0..14], Bernoulli );
#>[ 1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66, 0, -691/2730, 0, 7/6 ]
Bernoulli( 80 );
#>-4603784299479457646935574969019046849794257872751288919656867/230010

# thats it for the combinatorical package  ##################################
#Print( "$Id: combinat.tst,v 3.2 1992/11/25 14:49:10 martin Exp $  ",
#       QuoInt(700000000,time), " GAPstones\n" );
#if IsBound( GAPSTONES )  then Add( GAPSTONES, QuoInt(700000000,time) );  fi;



#############################################################################
##
##  ffld.in                     GAP tests                    Martin Schoenert
##
a := (1,2,3);;
b := (2,3,4,5,6);;
G := Group( a, b );;
H := Operation( G, Cosets(G,Subgroup(G,[a])), OnRight );;
d := 120;;
ma := PermutationMat( H.1, d, GF(2) );;
mb := PermutationMat( H.2, d, GF(2) );;
desc := [ [ ma, mb ], GF(2), d ];;
cfac := MTXOps.CompositionFactors( desc );;
Print( Collected( cfac.groups{[1..Length(cfac.groups)]}[3] ), "\n" );

Unbind( a );
Unbind( b );
Unbind( G );
Unbind( H );
Unbind( d );
Unbind( ma );
Unbind( mb );
Unbind( desc );
Unbind( cfac );
GASMAN("collect");


#############################################################################
##
##  bloc.in                     GAP tests                    Martin Schoenert
##
n := 8;;
q := 3;;
V := Tuples( Elements( GaloisField(q) ), n );;
# entferne den Nullvektor
V := V{[2..q^n]};;
# permutiere die Elemente zuf"allig
for i  in [1..q^n-2]  do
    k := RandomList( [i..q^n-1] );
    x := V[i];  V[i] := V[k];  V[k] := x;
od;
# mache die Permutationsgruppe
G := Operation( GeneralLinearGroup(n,q), V );;
# bestimme ein Blocksystem
B := Blocks( G, [1..q^n-1] );;
Print( Length(B), "\n" );
H := Operation( G, B, OnSets );;
C := Blocks( H, [1..(q^n-1)/(q-1)] );;
Print( Length(C), "\n" );

Unbind( V );
Unbind( G );
Unbind( B );
Unbind( H );
Unbind( C );
GASMAN( "collect" );


#############################################################################
##
##  latt.in                     GAP tests                    Martin Schoenert
##
G := Group( (1,2), (1,2,3,4,5,6,7) );;

L := Lattice( G );;
n1 := Length( L.classes );;
n2 := Sum( [1..n1], i -> Size( L.classes[i] ) );;
Print( "G has ", n1, " classes of altogether ", n2, " subgroups.\n" );

Unbind( G );
Unbind( L );
Unbind( n1 );    Unbind( n2 );


#############################################################################
##
##  rako.in                     GAP tests                      Ferenc Rakoczi
##
PermWreathProd:=function(G1,G2)
local n,m,newgens,g,i,j,permlist;

 if(IsTrivial(G1)) then return G2; fi;
 if(IsTrivial(G2)) then return G1; fi;
 n:=PermGroupOps.LargestMovedPoint(G1);
 m:=PermGroupOps.LargestMovedPoint(G2);
 newgens:=Copy(G1.generators);
 permlist:=[1..n*m];
 for g in G2.generators do
  for i in [1..n] do
   for j in [1..m] do
    permlist[(j-1)*n+i]:=(j^g-1)*n+i;
   od;
  od;
  Add(newgens,PermList(permlist));
 od;
 return Group(newgens,());
end;;

S4:=Group((1,2),(1,2,3,4));;

# Read("EANS.g");

#B  Begin EANS.g

# The main functions in this file are  ElementaryAbelianNormalSeries(G),
# Normalsift(G, primes, functions)  and  SylowSubgroupSolvableGroup(G,p).
# The argument  G  is always a solvable group, and the argument  p  is a
# prime number.
# ElementaryAbelianNormalSeries(G)  returns a record with fields
#  primes  and  functions . The two lists have the same lengths, and
# if primes=[p_1,...,p_k] and functions=[f_1,...,f_k], then G has a
# normal series  G=G_0 \geq G_1 \geq ... \geq G_k=1, such that  G_{i-1}/G_i
# is an elementary abelian p_i-group (possibly trivial), and  f_i is
# a homomorphism mapping  G_{i-1} to a subspace of  GF(p_i)^{l_i} where
#  l_i  is the length of the vector  f_i(g)  (for any g in G_{i-1}).
# ( f_i  may return the zero-vector as the integer 0)
# Normalsift(G, primes, functions)  takes the fields of the record computed
# by ElementaryAbelianNormalSeries(G) and sifts the generators of  G  through
# the structure they represent, returning a record, with three fields,
#  sgs ,  primes  and  functions , all three of lists of equal length of  m ,
# such that  G has a normal series  G=G_0 > G_1 > ... > G_m=1,  G_{i-1}/G_i
# is an elementary abelian p_i-group (nontrivial), f_i is a homomorphism
# mapping  G_{i-1} onto a subspace GF(p_i)^{d_i} where  d_i  is the length
# of the vector  f_i(g)  (for any g in G_{i-1}), and  sgs_i  is a list of
# length  d_i  of elements of  G_{i-1}\G_i  such that <G_i,sgs_i>=G_{i-1}.
# SylowSubgroupSolvableGroup(G,p) computes a Sylow p-subgroup of  G  using
# the structure computed by  ElementaryAbelianNormalSeries  and
#  Normalsift .


# computes a function that returns the relevant coordinates
siftfun:=function(indices,func)
 return function(g)
         local vec,i;
         vec:=func(g);
         if vec=0 then
          vec:=[1..Length(indices)];
          for i in [1..Length(indices)] do vec[i]:=0; od;
          return vec;
         else
          return vec{indices};
         fi;
        end;
end;;



# Normalsift(G, primes, functions)  takes the fields of the record computed
# by ElementaryAbelianNormalSeries(G) and sifts the generators of  G  through
# the structure they represent, returning a record, with three fields,
#  sgs ,  primes  and  functions , all three of lists of equal length of  m ,
# such that  G has a normal series  G=G_0 > G_1 > ... > G_m=1,  G_{i-1}/G_i
# is an elementary abelian p_i-group (nontrivial), f_i is a homomorphism
# mapping  G_{i-1} onto a subspace GF(p_i)^{d_i} where  d_i  is the length
# of the vector  f_i(g)  (for any g in G_{i-1}), and  sgs_i  is a list of
# length  d_i  of elements of  G_{i-1}\G_i  such that <G_i,sgs_i>=G_{i-1}.
#
NormalSift:=function(arg)
local G, primes, functions,
      sgs, sgsvecs, sigpos, len, stack, gens, g, i, vector, veclen,
      genlen, j, exp, k, what, gpos, newsgs, newprimes, newfunctions,
      newi, vector2, l, pos;

 if Length(arg)<>3 and Length(arg)<>4 then
  Error("Number of args must be 3 or 4");
 fi;
 G:=arg[1];
 primes:=arg[2];
 functions:=arg[3];
 if Length(arg)<>3 then return rec(primes:=primes,functions:=functions); fi;
 sgs:=List(primes, x->[]);
 sgsvecs:=List(primes, x->[]);
 sigpos:=List(primes, x->[]);
 len:=Length(primes);
 stack:=[];
 gens:=[];

 # sift the generators
 for g in G.generators do
  i:=1;
  while g<>() and i<=len do
   vector:=functions[i](g);
   if vector=0 then i:=i+1;  # 0-vector cleares the level without modification
   else
    veclen:=Length(vector);
    genlen:=Length(sigpos[i]);
    for j in [1..genlen] do
     if vector[sigpos[i][j]]<>0 then
      exp:=vector[sigpos[i][j]];
      vector:=vector-exp*sgsvecs[i][j];
      for k in [1..veclen] do vector[k]:=vector[k] mod primes[i]; od;
      g:=g*sgs[i][j]^(-exp);
     fi;
    od;
    j:=1;
    while j <= veclen and vector[j]=0 do j:=j+1; od;
    if j<= veclen then   # new element of sgs
     exp:=1/vector[j] mod primes[i];
     Add(sgs[i],g^exp);
     vector:=exp*vector;
     for k in [1..veclen] do vector[k]:=vector[k] mod primes[i]; od;
     Add(sgsvecs[i],vector);
     Add(sigpos[i],j);
     for j in [1..len] do
      for k in [1..Length(sgs[j])] do Add(stack,["conj",j,k,i,genlen+1]); od;
     od;
     g:=g^primes[i];
     if g <> () then Add(stack,["ppow",i+1,g]); fi;
     Add(gens,[i,genlen+1]);
     g:=(); # to exit the while loop
    else   # i.e. when it cleared this level
     i:=i+1;
    fi;
   fi;
  od;

  # process stack
  while stack<>[] do
   what:=stack[Length(stack)];
   Unbind(stack[Length(stack)]);
   if what[1]="conj" then
    if what[2]<=what[4] then
      i:=what[4];
      g:=Comm(sgs[what[2]][what[3]],sgs[what[4]][what[5]]);
    else
      i:=what[2];
      g:=sgs[what[2]][what[3]]^sgs[what[4]][what[5]];
    fi;
   elif what[1]="comm" then
    i:=what[2]+1;
    g:=Comm(sgs[what[2]][what[3]],sgs[what[2]][what[4]]);
   elif what[1]="ppow" then
    i:=what[2];
    g:=what[3];
   else Error("corrupted entry on stack");
   fi;

   while g<>() and i<=len do  # sift
    vector:=functions[i](g);
    if vector=0 then i:=i+1;  # 0-vector cleares the level without modification
    else
     veclen:=Length(vector);
     genlen:=Length(sigpos[i]);
     for j in [1..genlen] do
      if vector[sigpos[i][j]]<>0 then
       exp:=vector[sigpos[i][j]];
       vector:=vector-exp*sgsvecs[i][j];
       for k in [1..veclen] do vector[k]:=vector[k] mod primes[i]; od;
       g:=g*sgs[i][j]^(-exp);
      fi;
     od;
     j:=1;
     while j <= veclen and vector[j]=0 do j:=j+1; od;
     if j<= veclen then   # new element of sgs
      exp:=1/vector[j] mod primes[i];
      Add(sgs[i],g^exp);
      vector:=exp*vector;
      for k in [1..veclen] do vector[k]:=vector[k] mod primes[i]; od;
      Add(sgsvecs[i],vector);
      Add(sigpos[i],j);
      for gpos in gens do
       Add(stack,["conj",i,genlen+1,gpos[1],gpos[2]]);
      od;
      for j in [1..genlen] do
       Add(stack,["comm",i,j,genlen+1]);
      od;
      g:=g^primes[i];
      if g <> () then Add(stack,["ppow",i+1,g]); fi;
      Add(gens,[i,genlen+1]);
      g:=(); # to exit the while loop
     else   # i.e. when it cleared this level
      i:=i+1;
     fi;
    fi;
   od;

  od;
 od;

 # compute the "tight structure"
 newsgs:=[];
 newprimes:=[];
 newfunctions:=[];
 newi:=1;
 for i in [1..len] do
  if sgs[i]<>[] then
   genlen:=Length(sgs[i]);
   for j in [2..genlen] do        # Gaussian elimination to get unit vectors
    pos:=sigpos[i][j];
    vector:=sgsvecs[i][j];
    veclen:=Length(vector);
    for k in [1..j-1] do
     vector2:=sgsvecs[i][k];
     exp:=vector2[pos];
     if exp<>0 then
      sgsvecs[i][k]:=sgsvecs[i][k]-exp*vector;          # vector operations!
      for l in [1..veclen] do
       sgsvecs[i][k][l]:=sgsvecs[i][k][l] mod primes[i];
      od;
      sgs[i][k]:=sgs[i][k]*sgs[i][j]^(-exp);
     fi;
    od;
   od;
   newsgs[newi]:=sgs[i];
   newprimes[newi]:=primes[i];
   newfunctions[newi]:=siftfun(sigpos[i],functions[i]);
   newi:=newi+1;
  fi;
 od;

 return rec(sgs:=newsgs,primes:=newprimes,functions:=newfunctions);
end;;


# this function does the work for
# AbelianNormalSubgroupPrimitiveSolvablePermGroup()
# g should be the permutation corresponding to the last member of slp
#
RecAbNormSbgrpPrimSolvGrp:=function(G,g)
local Y,U,H,y,uind,u,z,i;

 if g=() then
   g:=G.generators[1];
 fi;
 Y:=[g];
 H:=Group(());
 U:=Size(H);  # compute stab.chain for H
 U:=[];
 while Length(Y)>0 do
   y:=Y[Length(Y)];
   Unbind(Y[Length(Y)]);
   for uind in [1..Length(U)] do
     z:=Comm(U[uind],y);
     if z<>() then
       return RecAbNormSbgrpPrimSolvGrp(G,z);
     fi;
   od;
   if not y in H then
     U[Length(U)+1]:=y;
     H:=ClosureNormalizingElementPermGroup(H,y);
     for i in [1..Length(G.generators)] do
       Y[Length(Y)+1]:=y^G.generators[i];
     od;
   fi;
 od;
 return U;
end;;


# for G primitive solvable group it returns generators for its elementary
# abelian normal subgroup along with a straight line program to compute
# them from the generators of G
#
AbelianNormalSubgroupPrimitiveSolvablePermGroup:=function(G)
 return RecAbNormSbgrpPrimSolvGrp(G,G.generators[1]);
end;;

ctelabtrgroup:=function(gens,p,k)
local n, permlist, d, j, i, checklist, gen;

 n:=p^k;
 permlist:=List([1..n],x->-1);
 permlist[1]:=0;
 checklist:=List([1..n],x->false);
 checklist[1]:=true;
 d:=1;
 for gen in gens do
  for i in [1..n] do
   if checklist[i] then
    for j in [1..p-1] do
     permlist[i^gen]:=permlist[i]+d;
     i:=i^gen;
    od;
   fi;
  od;
  for i in [1..n] do if permlist[i] <> -1 then checklist[i]:=true; fi; od;
  d:=d*p;
 od;
 for i in [1..n] do if permlist[i]=0 then permlist[i]:=n; fi; od;
 return PermList(permlist);
end;;

# for memoizing standard generators
PPPprimes:=[];;
PPP:=List([1..100],x->[]);;
#
# computes the standard generating system for the canonical transitive
# elem. ab. group on {1,...,p^k}
#
ElAbGens:=function(p,k)
local gens,permlist,p0,i,j;

 gens:=[1..k];
 permlist:=[0..p^k-1];
 permlist[1]:=p^k;
 p0:=PermList(permlist);
 for i in [1..k] do
  for j in [1..p^i-p^(i-1)] do permlist[j]:=j+p^(i-1); od;
  for j in [p^i-p^(i-1)+1..p^i] do permlist[j]:=j+p^(i-1)-p^i; od;
  for j in [p^i+1..p^k] do permlist[j]:=permlist[j-p^i]+p^i; od;
  gens[i]:=PermList(permlist)^p0;
 od;
 return gens;
end;;

# computes the residue of  perm  that fixes the point  n (=p^k), after
# dividing out a member of the canonical elem. ab. group
#
primtop:=function(perm,p,k,n)
local l, vec, i, vec2, permlist, j, digit, sum, gens, gen;

 if p>100 then
  i:=100;
  while i <= Length(PPP) and PPPprimes[i-100] <> p do i:=i+1; od;
  if i>Length(PPP) then
    PPPprimes[i-100]:=p;
    PPP[i]:=[];
  fi;
  if not IsBound(PPP[i][k]) then PPP[i][k]:=ElAbGens(p,k); fi;
  gens:=PPP[i][k];
 else
  if not IsBound(PPP[p][k]) then PPP[p][k]:=ElAbGens(p,k); fi;
  gens:=PPP[p][k];
 fi;
 gen:=();
 l:=n^perm;
 if l=n then return perm; fi;
 for i in [1..k] do
  j:=l mod p;
  l:=(l-j)/p;
  gen:=gen*gens[i]^j;
 od;
 return perm*gen^(-1);
#
## here is an alternative way of doing this without memoization, this appears
## to run much slower...
#
# l:=n^perm;
# vec:=[1..k];
# for i in [1..k] do vec[i]:=l mod p; l:=(l-vec[i])/p; od;
# vec2:=List([1..k],x->0);
# permlist:=[1..n];
# for i in [1..n] do
#  j:=0;
#  repeat
#   j:=j+1;
#   vec2[j]:=vec2[j]+1;
#   if vec2[j]=p then vec2[j]:=0; fi;
#  until vec2[j] <> 0 or j=k;
#  sum:=0;
#  for j in [k,k-1..1]	 do
#   digit:=vec[j]+vec2[j];
#   if digit>=p then digit:=digit-p; fi;
#   sum:=sum*p+digit;
#  od;
#  if sum=0 then sum:=n; fi;
#  permlist[i]:=sum;
# od;
# return perm*PermList(permlist)^(-1);
end;;


# composes the homomorphism that maps a primitive solvable group to its
# point stabilizer subgroup with the homomorphism represented by  func
# and returns the resulting function
#
primtopfunc:=function(transformer,p,k,n,func)
 return function(g)
         if g=() then return 0; fi;
         return func(primtop(g^transformer,p,k,n));
        end;
end;;


# returns a function that computes the vector image of a permutation of
# the elementary abelian normal subgroup of a primitive solvable group.
#
primbottomfunc:=function(transformer,transformerinv,p,k,n)

 return function(g)
        local l, vec, i;
         l:=((n^transformerinv)^g)^transformer;
         if l=n then return 0; fi;
         vec:=[1..k];
         for i in [1..k] do vec[i]:=l mod p; l:=(l-vec[i])/p; od;
         return vec;
        end;
end;;


ElementaryAbelianNormalSeries:=function() return 0; end;; #"forward declaration"


# computes the structure for a primitive solvable group
#
EANSPrimitive:=function(G)
local n, prims, p, k, ansgens, transformer, newgens, gen, newgen,
      topstruct, primes, newfuncs, func, newfunc;

 n:=PermGroupOps.LargestMovedPoint(G);
 prims:=FactorsInt(n);
 p:=prims[1];
 k:=Length(prims);
 ansgens:=AbelianNormalSubgroupPrimitiveSolvablePermGroup(G);
 transformer:=ctelabtrgroup(ansgens,p,k);
 newgens:=[];
 for gen in G.generators do
  newgen:=primtop(gen^transformer,p,k,n);
  if newgen<>() then Add(newgens,newgen); fi;
 od;
 topstruct:=ElementaryAbelianNormalSeries(Group(newgens,()),1);
 primes:=topstruct.primes;
 newfuncs:=[];
 for func in topstruct.functions do
  newfunc:=primtopfunc(transformer,p,k,n,func);
  Add(newfuncs,newfunc);
 od;
 Add(newfuncs,primbottomfunc(transformer,transformer^(-1),p,k,n));
 Add(primes,p);
 return NormalSift(G,primes,newfuncs,1);
end;;


# composes the homomorphism that maps a transitive solvable group to its
# (primitive) action on a set of maximal blocks with the homomorphism
# represented by  func  and returns the resulting function
#
# compures a function that
#
transtopfunc:=function(m,blockreps,blocknum,func)
return function(g)
       local permlist,i;
        permlist:=[1..m];
        for i in [1..m] do permlist[i]:=blocknum[blockreps[i]^g]; od;
        g:=PermList(permlist);
        if g=() then return 0; fi;
        return func(g);
       end;
end;;


# combines the actions on the individual blocks of the kernel of the
# action on the blocks and returns the resulting map
#
transbottomfunc:=function(m,blocklen,forwardmaps,backwardmap,func)

 return function(g)

        local permlist,i,j,vector,vlen,gg,nullvec;
         vlen:=0;
         vector:=[1..m];
         for i in [1..m] do
          permlist:=[1..blocklen];
          for j in [1..blocklen] do
           permlist[j]:=backwardmap[forwardmaps[i][j]^g];
          od;
          gg:=PermList(permlist);
          vector[i]:=func(gg);
          if vlen=0 and vector[i]<>0 then vlen:=Length(vector[i]); fi;
         od;
         if vlen=0 then return 0; fi;
         nullvec:=[1..vlen];
         for i in [1..vlen] do nullvec[i]:=0; od;
         for i in [1..m] do
          if vector[i]=0 then vector[i]:=nullvec; fi;
         od;
         return Concatenation(vector);
        end;
end;;

# computes the structure for a transitive solvable group
#
EANSTransitive:= function(G)
local blocks, m, n, blocklen, blocknum, blockreps, i, j, newgens,
      gen, permlist, newgen, topstruct, primes, func, newfunctions,
      newfunc, inclosure, forwardmaps, backwardmap, bottomstruct,
      point, newpoints, newpoint;

 n:=PermGroupOps.LargestMovedPoint(G);
 blocks:=MaximalBlocks(G,[1..n]);
 m:=Length(blocks);
 if m=1 then return EANSPrimitive(G); fi;
 blocklen:=n/m;
 blocknum:=[1..n];
 for i in [1..m] do
  for j in blocks[i] do blocknum[j]:=i; od;
 od;
 blockreps:=[1..m];
 for i in [1..m] do blockreps[i]:=blocks[i][1]; od;

 # compute the action on the blocks
 newgens:=[];
 for gen in G.generators do
  permlist:=[1..m];
   for i in [1..m] do permlist[i]:=blocknum[blocks[i][1]^gen]; od;
  newgen:=PermList(permlist);
  if newgen<>() then Add(newgens,newgen); fi;
 od;
 topstruct:=EANSPrimitive(Group(newgens,()));
 primes:=topstruct.primes;
 newfunctions:=[];
 for func in topstruct.functions do
  newfunc:=transtopfunc(m,blockreps,blocknum,func);
  Add(newfunctions,newfunc);
 od;

 # compute transitive closure on the blocks
 inclosure:=List([1..m],x->false);
 forwardmaps:=List([1..m],x->[1..blocklen]);
 backwardmap:=[1..n];
 for i in [1..blocklen] do
  forwardmaps[1][i]:=blocks[1][i];
  backwardmap[blocks[1][i]]:=i;
 od;
 inclosure[1]:=true;
 newpoints:=[1];
 for point in newpoints do
  for gen in G.generators do
   newpoint:=blocknum[blockreps[point]^gen];
   if not inclosure[newpoint] then
    for j in [1..blocklen] do
     forwardmaps[newpoint][j]:=forwardmaps[point][j]^gen;
     backwardmap[forwardmaps[point][j]^gen]:=j;
    od;
    Add(newpoints,newpoint);
    inclosure[newpoint]:=true;
   fi;
  od;
 od;

 # compute Schreier generators for G_{\{\Omega_1\}}^{\Omega_1}
 newgens:=[];
 for i in [1..m] do
  for gen in G.generators do
   permlist:=[1..blocklen];
   for j in [1..blocklen] do
    permlist[j]:=backwardmap[forwardmaps[i][j]^gen];
   od;
   newgen:=PermList(permlist);
   if newgen<>() then Add(newgens, newgen); fi;
  od;
 od;

 bottomstruct:=EANSTransitive(Group(newgens,()));
 Append(primes,bottomstruct.primes);
 for func in bottomstruct.functions do
  newfunc:=transbottomfunc(m,blocklen,forwardmaps,backwardmap,func);
  Add(newfunctions,newfunc);
 od;
 return NormalSift(G,primes,newfunctions,1);
end;;

# composes the homomorphism that maps an intransitive solvable group to its
# (transitive) action on a st of maximal blocks with the homomorphism
# represented by  func  and returns the resulting function
#
orbitfunc:=function (m,backwardmap,forwardmap,func)
return function(g)
       local permlist,i;
        permlist:=[1..m];
        for i in [1..m] do permlist[i]:=backwardmap[forwardmap[i]^g]; od;
        g:=PermList(permlist);
        if g=() then return 0; fi;
        return func(g);
       end;
end;;


# ElementaryAbelianNormalSeries(G)  returns a record with fields
#  primes  and  functions . The two lists have the same lengths, and
# if primes=[p_1,...,p_k] and functions=[f_1,...,f_k], then G has a
# normal series  G=G_0 \geq G_1 \geq ... \geq G_k=1, such that  G_{i-1}/G_i
# is an elementary abelian p_i-group (possibly trivial), and  f_i is
# a homomorphism mapping  G_{i-1} to a subspace of  GF(p_i)^{l_i} where
#  l_i  is the length of the vector  f_i(g)  (for any g in G_{i-1}).
# ( f_i  may return the zero-vector as the integer 0)
#
ElementaryAbelianNormalSeries:= function(arg)
local  m, n, orbit, orbits, base, H, goodorbits, forwardmap, backwardmap,
       i, j, gen, newgens, newfunctions, permlist, g, orbitstruct, primes,
       func, newfunc, G, flag;

 if Length(arg)=0 or Length(arg)>2 then
  Error("Number of arguments must be 1 or 2");
 fi;
 if Length(arg)=2 then flag:=arg[2]; # if called with two argument, it is
 else flag:=0;                       # a recursive call, therefore the group
 fi;                                 # is a subgroup of a primitive solvable
                                     # group, so it is small
 G:=arg[1];

 if G.generators=[] then             # handle the trivial case
  return rec(sgs:=[],primes:=[],functions:=[]);
 fi;

 n:=PermGroupOps.LargestMovedPoint(G);
 orbits:=Orbits(G,[1..n]);
 if Length(orbits)=1 then return EANSTransitive(G); fi;

 if flag=1 then                               # small group, cut down the
  PermGroupOps.TryElementaryAbelianSeries(G); # number of orbits
  H:=G;
  base:=[];
  while H.generators <> [] do
   Add(base,H.orbit[1]);
   H:=H.stabilizer;
  od;
  goodorbits:=[];
  for i in base do
   j:=1;
   while j<=Length(orbits) do
    if i in orbits[j] then
     Add(goodorbits,orbits[j]);
     orbits[j]:=orbits[Length(orbits)];
     j:=Length(orbits);
     Unbind(orbits[j]);
    else
     j:=j+1;
    fi;
   od;
  od;
  orbits:=goodorbits;
 fi;

 newfunctions:=[];
 primes:=[];

 for orbit in orbits do    # compute structure for transitive constituents
  m:=Length(orbit);
  if m>1 then
   forwardmap:=Copy(orbit);
   backwardmap:=[1..n];
   for i in [1..m] do backwardmap[orbit[i]]:=i; od;
   newgens:=[];
   for gen in G.generators do
    permlist:=[1..m];
    for i in [1..m] do permlist[i]:=backwardmap[forwardmap[i]^gen]; od;
    g:=PermList(permlist);
    if g<>() then Add(newgens,g); fi;
   od;
   orbitstruct:=EANSTransitive(Group(newgens,()));
   Append(primes,orbitstruct.primes);
   for func in orbitstruct.functions do
    newfunc:=orbitfunc(m,backwardmap,forwardmap,func);
    Add(newfunctions,newfunc);
   od;
  fi;
 od;
 return NormalSift(G,primes,newfunctions,1);
end;;


# size of group is easy to compute from structure
#
SizeSolvableGroup:=function(G)
local elabstructure, i, size;

 size:=1;
#Print(Runtime(),"  ");
 elabstructure:=ElementaryAbelianNormalSeries(G);
#Print(Runtime(),"  ");
 elabstructure:=NormalSift(G,elabstructure.primes,elabstructure.functions);
 for i in [1..Length(elabstructure.primes)] do
  size:=size*elabstructure.primes[i]^Length(elabstructure.sgs[i]);
 od;
#Print(Runtime(),"\n");
 return size;
end;;


# returns a solution of DD*x=bb mod p, or  false, if there are no solutions
#
SolveLinSystem:=function(DD,bb,p)
local D, b, nrows, ncols, c, cc, pivots, pivotcols, i, j, k, d, l, e;

 D:=Copy(DD);
 b:=Copy(bb);
 nrows:=Length(D);
 ncols:=Length(D[1]);
 c:=[1..nrows];
 pivots:=[];
 pivotcols:=[];
 for i in [1..ncols] do
  for j in [1..nrows] do
   if not j in pivots and D[j][i]<>0 then
    cc:=D[j][i];
    for k in pivots do
     if D[k][i]<>0 then
      d:=(D[k][i]/cc) mod p;
      for l in [i..ncols] do D[k][l]:=(D[k][l]-D[j][l]*d) mod p; od;
      b[k]:=(b[k]-b[j]*d) mod p;
     fi;
    od;
    for k in [j+1..nrows] do
     if D[k][i]<>0 then
      d:=(D[k][i]/cc) mod p;
      for l in [i..ncols] do D[k][l]:=(D[k][l]-D[j][l]*d) mod p; od;
      b[k]:=(b[k]-b[j]*d) mod p;
     fi;
    od;
    c[j]:=cc;
    Add(pivots,j);
    Add(pivotcols,i);
   fi;
  od;
 od;
 e:=List([1..ncols],x->0);
 for j in [1..nrows] do
  if b[j]<>0 and not j in pivots then return false; fi;
 od;
 for j in [1..Length(pivots)] do
  e[pivotcols[j]]:=(b[pivots[j]]/c[pivots[j]]) mod p;
 od;
 return e;
end;;


# evaluates a straight line program  slp  on  gens
#
EvalSlp:=function(slp,gens)
local i, k, vals, what;

 k:=Length(slp);
 vals:=[1..k];
 for i in [1..k] do
  what:=slp[i][1];
  if what="gen" then
   vals[i]:=gens[slp[i][2]];
  elif what="pow" then
   vals[i]:=vals[slp[i][2]]^slp[i][3];
  elif what="*" then
   vals[i]:=vals[slp[i][2]]*vals[slp[i][3]];
  elif what="conj" then
   vals[i]:=vals[slp[i][2]]^vals[slp[i][3]];
  elif what="inv" then
   vals[i]:=vals[slp[i][2]]^-1;
  elif what="comm" then
   vals[i]:=Comm(vals[slp[i][2]],vals[slp[i][3]]);
  fi;
 od;
 return vals[k];
end;;


# computes the complement of an elementary abelian normal subgroup
# by solving a set of linear equations
#
ComplementElAbSubgroup:=function(gens,rels, qgens,vecfun,q)
local dim, ncol, xlen, ig, b, D, hs, g, vec, i, j, z, k, hs, h, e;

 dim:=Length(qgens);
 xlen:=Length(gens);
 for ig in [xlen,xlen-1..1] do
  ncol:=dim*Length(rels[ig]);
  b:=[1..ncol];
  D:=[1..ncol];
  for i in [1..ncol] do D[i]:=[1..dim]; od;
  hs:=Copy(gens);
  for i in [1..Length(rels[ig])] do
   g:=EvalSlp(rels[ig][i],gens)^-1;
   vec:=vecfun(g);
   for j in [1..dim] do b[(i-1)*dim+j]:=vec[j]; od;
   for k in [1..dim] do
    hs[ig]:=gens[ig]*qgens[k];
    h:=g*EvalSlp(rels[ig][i],hs);
    vec:=vecfun(h);
    for j in [1..dim] do D[(i-1)*dim+j][k]:=vec[j]; od;
   od;
  od;
  e:=SolveLinSystem(D,b,q);
  for k in [1..dim] do
   gens[ig]:=gens[ig]*qgens[k]^e[k];
  od;
 od;
 return gens;
end;;

# extends the constructive presentation of a factorgroup by the next
# (elementary abelian) piece.
#
ExtendPresentation:=function(gens1,rels1, gens2, vecfun, p)
local k, m, gens, rels, ig, rel, vec, reltail, l, i, j, z;

 k:=Length(gens1);
 m:=Length(gens2);
 gens:=Concatenation(gens1,gens2);
 rels:=List(gens,x->[]);

 for ig in [1..k] do
  for rel in rels1[ig] do
   vec:=vecfun(EvalSlp(rel,gens1));
   reltail:=[];
   l:=Length(rel);
   for i in [1..m] do
    Append(reltail,[["gen",k+i],["pow",l+1,-vec[i]],["*",l,l+2]]);
    l:=l+3;
   od;
   Add(rels[ig],Concatenation(rel,reltail));
  od;
 od;

 for i in [1..k] do
  for j in [1..m] do
   rel:=[["gen",i],["gen",k+j],["conj",2,1]];
   vec:=vecfun(gens2[j]^gens1[i]);
   reltail:=[];
   l:=Length(rel);
   for z in [1..m] do
    Append(reltail,[["gen",k+z],["pow",l+1,p-vec[z]],["*",l,l+2]]);
    l:=l+3;
   od;
   Add(rels[i],Concatenation(rel,reltail));
  od;
 od;

 for i in [1..m] do
  Add(rels[k+i],[["gen",k+i],["pow",1,p]]);
  for j in [i+1..m] do
   Add(rels[k+i],[["gen",k+i],["gen",k+j],["comm",1,2]]);
  od;
 od;
 return rec(generators:=gens,relators:=rels);
end;;



# computes a Sylop p-subgroup of the solvable group  G
#
SylowSubgroupSolvableGroup:=function(G,p)
local eans, relators, generators, primes, sgs, functions, t, i, ext,
      t0, t1, t2, t3;

t0:=Runtime();
 eans:=ElementaryAbelianNormalSeries(G);
t1:=Runtime();
#Print("\nmaps:",t1-t0," \c");
 eans:=NormalSift(G,eans.primes,eans.functions);
t2:=Runtime();
#Print("Normalsift:",t2-t1," \c");
 if not (p in eans.primes) then return Group(()); fi;
 relators:=[];
 generators:=[];
 primes:=eans.primes;
 sgs:=eans.sgs;
 functions:=eans.functions;
 t:=Length(eans.primes);
 i:=1;
 while primes[i]<>p do i:=i+1; od;
 while t>=i and primes[t]=p do t:=t-1; od;
#Print(eans,"\ni=",i,"  t=",t,"\n");
 while i<=t do
  if primes[i]=p then
#Print("generators:=",generators,"\nrelators:=",relators,"\n");
    ext:=ExtendPresentation(generators,relators, sgs[i],functions[i],p);
#Print("presentation extended(i=",i,"):\n",
#      Length(ext.generators), " generators, ",Sum(List(ext.relators,Length)),
#      " relators\n",ext,"\n");
    generators:=ext.generators;
    relators:=ext.relators;
  else
    generators:=ComplementElAbSubgroup(generators,relators,
                                       sgs[i],functions[i],primes[i]);
#Print("complement computed(i=",i,"):\n",generators,"\n");
  fi;
  i:=i+1;
 od;
 for i in [t+1..Length(sgs)] do Append(generators,sgs[i]); od;
t3:=Runtime();
#Print("\nSylow:",t3-t2," total: ",t3-t0,"\n");
 return Group(generators,());
end;;

ExtendPresentationVals:=function(gens1,rels1, vals1, gens2, vecfun, p)
local k, m, gens, rels, vals, ig, g, rel, vec, reltail, l, i, j, z;

 k:=Length(gens1);
 m:=Length(gens2);
 gens:=Concatenation(gens1,gens2);
 rels:=List(gens,x->[]);
 vals:=List(gens,x->[]);

 for ig in [1..k] do
  for j  in [1..Length(rels1[ig])] do
   vec:=vecfun(vals1[ig][j]);
   g:=vals1[ig][j];
   rel:=rels1[ig][j];
   reltail:=[];
   l:=Length(rel);
   for i in [1..m] do
    Append(reltail,[["gen",k+i],["pow",l+1,-vec[i]],["*",l,l+2]]);
    g:=g*gens2[i]^(-vec[i]);
    l:=l+3;
   od;
   Add(rels[ig],Concatenation(rel,reltail));
   Add(vals[ig],g);
  od;
 od;

 for i in [1..k] do
  for j in [1..m] do
   rel:=[["gen",i],["gen",k+j],["conj",2,1]];
   g:=gens2[j]^gens1[i];
   vec:=vecfun(gens2[j]^gens1[i]);
   reltail:=[];
   l:=Length(rel);
   for z in [1..m] do
    Append(reltail,[["gen",k+z],["pow",l+1,p-vec[z]],["*",l,l+2]]);
    g:=g*gens2[z]^(p-vec[z]);
    l:=l+3;
   od;
   Add(rels[i],Concatenation(rel,reltail));
   Add(vals[i],g);
  od;
 od;

 for i in [1..m] do
  Add(rels[k+i],[["gen",k+i],["pow",1,p]]);
  Add(vals[k+i],gens2[i]^p);
  for j in [i+1..m] do
   Add(rels[k+i],[["gen",k+i],["gen",k+j],["comm",1,2]]);
   Add(vals[k+i],Comm(gens2[i],gens2[j]));
  od;
 od;
 return rec(generators:=gens,relators:=rels, values:=vals);
end;;


AgGroupSolvableGroup:=function(G)
local eans, relators, generators, values, primes, sgs, functions, t, i, ext,
      t0, t1, t2, t3;

t0:=Runtime();
 eans:=ElementaryAbelianNormalSeries(G);
t1:=Runtime();
#Print("\nmaps:",t1-t0," \c");
 eans:=NormalSift(G,eans.primes,eans.functions);
t2:=Runtime();
#Print("Normalsift:",t2-t1," \c");
 relators:=[];
 generators:=[];
 values:=[];
 primes:=eans.primes;
 sgs:=eans.sgs;
 functions:=eans.functions;
 t:=Length(eans.primes);
 i:=1;
 for i in [1..t] do
    ext:=ExtendPresentationVals(generators,relators, values,
                            sgs[i],functions[i],primes[i]);
    generators:=ext.generators;
    relators:=ext.relators;
    values:=ext.values;
 od;
t3:=Runtime();
#Print("convert:",t3-t2," total: ",t3-t0,"\n");
 return [generators,relators];
end;;

#E  End of EANS.g


# Read("examples.g");

#B  Begin examples.g

PermWreathProd:=function(G1,G2)
local n,m,newgens,g,i,j,permlist;

 if(IsTrivial(G1)) then return G2; fi;
 if(IsTrivial(G2)) then return G1; fi;
 n:=PermGroupOps.LargestMovedPoint(G1);
 m:=PermGroupOps.LargestMovedPoint(G2);
 newgens:=Copy(G1.generators);
 permlist:=[1..n*m];
 for g in G2.generators do
  for i in [1..n] do
   for j in [1..m] do
    permlist[(j-1)*n+i]:=(j^g-1)*n+i;
   od;
  od;
  Add(newgens,PermList(permlist));
 od;
 return Group(newgens,());
end;;


PermDirectProd:=function(G1,G2)
local n,m,newgens,g,i,j,permlist;

 if(IsTrivial(G1)) then return G2; fi;
 if(IsTrivial(G2)) then return G1; fi;
 n:=PermGroupOps.LargestMovedPoint(G1);
 m:=PermGroupOps.LargestMovedPoint(G2);
 newgens:=Copy(G1.generators);
 permlist:=[1..n+m];
 for g in G2.generators do
   for j in [1..m] do
    permlist[n+j]:=n+j^g;
   od;
  Add(newgens,PermList(permlist));
 od;
 return Group(newgens,());
end;;


p_grp:= function(p,n)
local i,k,ii,l,j,gens,t,first,pow,rem;

 gens:=[];
 rem:=n;
 first:=1;
 i:=1;
 while rem>=p do
  k:=1;
  pow:=p;
  while pow*p<=rem do
   k:=k+1;
   pow:=pow*p;
  od;
  rem:=rem-pow;
  j:=1;
  for l in [1..k] do
   t:=[1..p*j];
   for ii in [1..p*j] do
    t[ii]:=((ii+j-1) mod (p*j))+1;
   od;
   gens[i]:=PermList(Concatenation([1..first-1],t+(first-1)));
   i:=i+1;
   j:=j*p;
  od;
  first:=first+pow;
 od;
 return Group(gens,());
end;;


NextVec:=function(v,p,d)
local i;

 i:=1;
 v[1]:=v[1]+1;
 while v[i]=p do
  v[i]:=0;
  i:=i+1;
  if i=d+1 then i:=1;  fi;
  v[i]:=v[i]+1;
 od;
end;;


VecToPoint:=function(v,p,d)
local i,n;

 n:=0;
 for i in [d,d-1..1] do
  n:=n*p+v[i];
 od;
 return n+1;
end;;


ModpVec:=function(v,p,d)
local i;

 for i in [1..d] do
  v[i]:=v[i] mod p;
 od;
 return v;
end;;


MatrixMultToPerm:=function(M,p,d)
local permvec,i,v;

 permvec:=[1..p^d];
 v:=List([1..d],x->0);
 for i in [1.. p^d] do
  permvec[i]:=VecToPoint(ModpVec(v*M,p,d),p,d);
  NextVec(v,p,d);
 od;
 return PermList(permvec);
end;;


VecAddToPerm:=function(w,p,d)
local permvec,i,v;

 permvec:=[1..p^d];
 v:=List([1..d],x->0);
 for i in [1.. p^d] do
  permvec[i]:=VecToPoint(ModpVec(v+w,p,d),p,d);
  NextVec(v,p,d);
 od;
 return PermList(permvec);
end;;


VectorSpaceToPerms:=function(p,d)
local vec,i,perms;

 vec:=List([1..d],x->0);
 perms:=[1..d];
 vec[1]:=1;
 for i in [1..d-1] do
  perms[i]:=VecAddToPerm(vec,p,d);
  vec[i]:=0;
  vec[i+1]:=1;
 od;
 perms[d]:=VecAddToPerm(vec,p,d);
 return perms;
end;;


PermToPermmat:=function(perm,d)
local i, M;

 M:=List([1..d],x->List([1..d],y->0));
 for i in [1..d] do M[i][i^perm]:=1; od;
 return M;
end;;


X_V_Generators:=function(p,d)
 return List(VectorSpaceToPerms(p,d),x->PermToPermmat(x,p^d));
end;;


Y_V_Generators:=function(p,d)
local vec,gens,M,v,i,j;

 vec:=List([1..d],x->0);
 gens:=[1..d];
 vec[1]:=1;
 M:=List([1..p^d],x->List([1..p^d],y->0));
 for i in [1..d] do
  v:=List([1..d],x->0);
  for j in [1..p^d] do
   M[j][j]:=(-1)^(vec*v);
   NextVec(v,p,d);
  od;
  gens[i]:=Copy(M);
  vec[i]:=0;
  if i<d then vec[i+1]:=1; fi;
 od;
 return gens;
end;;


GL_V_Generators:=function(matrices,p,d)
 return List(matrices,x->PermToPermmat(MatrixMultToPerm(x,p,d),p^d));
end;;


Example1:=function()
local A,B,matrixgens;

 A:=[ [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 0 ] ];
 B:=[ [ 1, 0, 0 ], [ 0, 0, 1 ], [ 0, 1, 1 ] ];
 matrixgens:=Concatenation(X_V_Generators(2,3),
                           Y_V_Generators(2,3),GL_V_Generators([A,B],2,3));
 return Group(Concatenation( List(matrixgens, x->MatrixMultToPerm(x,3,8)),
                              VectorSpaceToPerms(3,8)),());
end;;

#....setup:898130 Sylow:10790 total:908920
#4241750
#6764560

d_U_Generators:=function()
local p,d,Ulist,gens,M,i,v,j;

 Ulist:=
  [ [[0,1,0],[0,0,0],[0,0,0]],
    [[0,0,1],[0,0,0],[0,0,0]],
    [[0,1,1],[0,0,0],[0,0,0]],
    [[0,0,0],[0,0,1],[0,0,0]],
    [[0,1,0],[0,0,1],[0,0,0]],
    [[0,0,1],[0,0,1],[0,0,0]],
    [[0,1,1],[0,0,1],[0,0,0]] ];
 p:=2;
 d:=3;
 gens:=[1..Length(Ulist)];
 M:=List([1..p^d],x->List([1..p^d],y->0));
 for i in [1..Length(Ulist)] do
  v:=List([1..d],x->0);
  for j in [1..p^d] do
   M[j][j]:=(-1)^(v*Ulist[i]*v);
   NextVec(v,p,d);
  od;
  gens[i]:=Copy(M);
 od;
 return gens;
end;;

Example2:=function()
local A,B,matrixgens;

 A:=[ [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 0 ] ];
 B:=[ [ 1, 0, 0 ], [ 0, 0, 1 ], [ 0, 1, 1 ] ];
 matrixgens:=Concatenation(X_V_Generators(2,3),d_U_Generators(),
                           Y_V_Generators(2,3),GL_V_Generators([A,B],2,3));
 return Group(Concatenation( List(matrixgens, x->MatrixMultToPerm(x,3,8)),
                              VectorSpaceToPerms(3,8)),());
end;;


H_Generator:=function()
local p,d,H,v,i,u,j;

 p:=2;
 d:=2;
 H:=List([1..p^d],x->List([1..p^d],y->0));
 v:=List([1..d],x->0);
 for i in [1..p^d] do
   u:=List([1..d],x->0);
   for j in [1..p^d] do
     H[i][j]:=(-1)^(v*u);
     NextVec(u,p,d);
   od;
   NextVec(v,p,d);
 od;
 return [H];
end;;


Example3:=function()
local A,B,matrixgens;

 A:=[ [ 0, 1 ], [ 1, 1 ] ];
 B:=[ [ 1, 1 ], [ 0, 1 ] ];
 matrixgens:=Concatenation(X_V_Generators(2,2),H_Generator(),
                           Y_V_Generators(2,2),GL_V_Generators([A,B],2,2));
 return Group(Concatenation( List(matrixgens, x->MatrixMultToPerm(x,3,4)),
                              VectorSpaceToPerms(3,4)),());
end;;

#E  End of examples.g


Factorized:=function(n)
local str,prlist,i,p,exp;

 str:="";
 if n=1 then return "1"; fi;
 prlist:=Factors(n);
 i:=1;
 while i<=Length(prlist) do
  p:=prlist[i];
  exp:=0;
  while i<=Length(prlist) and prlist[i]=p do
   exp:=exp+1;
   i:=i+1;
  od;
  if exp>1 then
   str:=ConcatenationString(str,String(p),"^",String(exp));
  else
   str:=ConcatenationString(str,String(p));
  fi;
  if i<=Length(prlist) then str:=ConcatenationString(str,"*"); fi;
 od;
 return str;
end;;


OverAndBackSylow:=function(G,p)
local t0, t1, t2, t3, agG, phi, spagG, psi, spagSylpG, SylpG;

t0:=Runtime();
 agG:=AgGroup(G);
t1:=Runtime();
 phi:=agG.bijection;
 spagG:=SpecialAgGroup(agG);
t2:=Runtime();
 psi:=spagG.bijection;
 spagSylpG:=SylowSubgroup(spagG,p);
t3:=Runtime();
 SylpG:=Image(phi, Image(psi,spagSylpG));
#Print("\nSylow:",Runtime()-t0,"(",t1-t0,",",t2-t1,",",t3-t2,")\n");
Print("[sizes:",Factorized(Size(agG)),",",Factorized(Size(spagG)),
       ",",Factorized(Size(spagSylpG)),"]\c");
 return SylpG;
end;;

Test:=function(G,name)
local i,p,t0,size,R,GR,g1,g2,g3,g4;

 p:=3;
 Print("\n\n*********  ",name,"\n");
 t0:=Runtime();
 if IsSolvable(G) then
  size:=Size(G);
  #Print("size=",Factorized(size),"  time=",Runtime()-t0,"\c");
  R:=OverAndBackSylow(G,3);
  if IsSolvable(R) then
   Print("\nsize=",Factorized(Size(R)),"\c");
  else
   Print("oops...  overandback Sylow subgroup not solvable ????\n");
  fi;
  R:=SylowSubgroupSolvableGroup(G,p);
  if IsSolvable(R) then
   Print("size=",Factorized(Size(R)),"\n");
  else
   Print("oops...  Sylow subgroup not solvable ????\n");
  fi;

#  for i in [1..3] do
   g1:=Random(G);
   g2:=Random(G);
   g3:=Random(G);
   g4:=Random(G);
   g1:=Random(G); # repeated because the first set takes too long...
   g2:=Random(G);
   g3:=Random(G);
   g4:=Random(G);
   GR:=Group(g1,g2,g3,g4);

   t0:=Runtime();
   Print("\nSubgroup generated by 4 random elements...\n");
   if(IsSolvable(GR)) then
    size:=Size(GR);
    #Print("size=",Factorized(size),"  time=",Runtime()-t0,"\c");
    R:=OverAndBackSylow(GR,3);
    if IsSolvable(R) then
     Print("\nsize=",Factorized(Size(R)),"\c");
    else
     Print("oops...  overandback Sylow subgroup not solvable ????\n");
    fi;
    R:=SylowSubgroupSolvableGroup(GR,p);
    if IsSolvable(R) then
     Print("size=",Factorized(Size(R)),"\n");
    else
      Print("oops...  Sylow subgroup not solvable ????\n");
    fi;
   else
    Print("Random subgroup not solvable!!\n");
   fi;
#  od;
 else
  Print(name," is not solvable!\n");
 fi;
end;;


S_3:=Group((1,2,3),(1,2));;
Test(S_3,"S_3");

#G_1:=Example1();;
#G_2:=Example2();;
#G_3:=Example3();;
#C_35:=Group((1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
#26,27,28,29,30,31,32,33,34,35));;
S_4:=Group((1,2,3,4),(1,2));;

#Sy_3_21:=p_grp(3,21);;

#G_1wrS_3:=PermWreathProd(G_1,S_3);;
#G_2wrS_4:=PermWreathProd(G_2,S_4);;
#G_3wrS_4:=PermWreathProd(G_3,S_4);;
S_3wrS_4:=PermWreathProd(S_3,S_4);;
S_4wrS_4:=PermWreathProd(S_4,S_4);;
#C_35wrS_3wrS_4:=PermWreathProd(PermWreathProd(C_35,S_3),S_4);;
#S_4wrS_4xSy_3_21xS_3wrS_4:=
#  PermDirectProd(PermDirectProd(S_4wrS_4,Sy_3_21),S_3wrS_4);;
#GGG:=S_4wrS_4xSy_3_21xS_3wrS_4;
#MedDirectProd:= PermDirectProd(GGG,GGG);;
#BigDirectProd:= PermDirectProd(PermDirectProd(GGG,GGG),GGG);;
#LargeDirectProd:= PermDirectProd(MedDirectProd,MedDirectProd);;
#VeryLargeDirectProd:=PermDirectProd(MedDirectProd,BigDirectProd);;

#Print(Size(SylowSubgroup(VeryLargeDirectProd,3)),"\n");

#Test(MedDirectProd,"MedDirectProd");
#Test(BigDirectProd,"BigDirectProd");
#Test(LargeDirectProd,"LargeDirectProd");
#Test(VeryLargeDirectProd,"VeryLargeDirectProd");

Test(S_3wrS_4,"S_3wrS_4");
Test(S_4wrS_4,"S_4wrS_4");
#Test(S_4wrS_4xSy_3_21xS_3wrS_4,"S_4wrS_4xSy_3_21xS_3wrS_4");
#Test(C_35wrS_3wrS_4,"C_35wrS_3wrS_4");

#Test(G_3,"G_3");
#Test(G_3wrS_4,"G_3wrS_4");

#Test(G_1,"G_1");
#Test(G_2,"G_2");

#Test(G_1wrS_3,"G_1wrS_3");
#Test(G_2wrS_4,"G_2wrS_4");


